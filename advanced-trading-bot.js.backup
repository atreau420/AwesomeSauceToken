import { Web3 } from 'web3';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Complete ERC20 ABI with all necessary methods
const ERC20_ABI = [
    {
        "constant": true,
        "inputs": [],
        "name": "name",
        "outputs": [{"name": "", "type": "string"}],
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [],
        "name": "symbol",
        "outputs": [{"name": "", "type": "string"}],
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [],
        "name": "decimals",
        "outputs": [{"name": "", "type": "uint8"}],
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [{"name": "_owner", "type": "address"}],
        "name": "balanceOf",
        "outputs": [{"name": "balance", "type": "uint256"}],
        "type": "function"
    },
    {
        "constant": false,
        "inputs": [{"name": "_spender", "type": "address"}, {"name": "_value", "type": "uint256"}],
        "name": "approve",
        "outputs": [{"name": "", "type": "bool"}],
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [{"name": "_owner", "type": "address"}, {"name": "_spender", "type": "address"}],
        "name": "allowance",
        "outputs": [{"name": "", "type": "uint256"}],
        "type": "function"
    },
    {
        "constant": false,
        "inputs": [{"name": "_to", "type": "address"}, {"name": "_value", "type": "uint256"}],
        "name": "transfer",
        "outputs": [{"name": "", "type": "bool"}],
        "type": "function"
    },
    {
        "constant": false,
        "inputs": [{"name": "_from", "type": "address"}, {"name": "_to", "type": "address"}, {"name": "_value", "type": "uint256"}],
        "name": "transferFrom",
        "outputs": [{"name": "", "type": "bool"}],
        "type": "function"
    }
];

// DEX Router ABIs
const UNISWAP_ROUTER_ABI = [
    {
        "inputs": [
            {
                "components": [
                    {"internalType": "address", "name": "tokenIn", "type": "address"},
                    {"internalType": "address", "name": "tokenOut", "type": "address"},
                    {"internalType": "uint24", "name": "fee", "type": "uint24"},
                    {"internalType": "address", "name": "recipient", "type": "address"},
                    {"internalType": "uint256", "name": "deadline", "type": "uint256"},
                    {"internalType": "uint256", "name": "amountIn", "type": "uint256"},
                    {"internalType": "uint256", "name": "amountOutMinimum", "type": "uint256"},
                    {"internalType": "uint160", "name": "sqrtPriceLimitX96", "type": "uint160"}
                ],
                "internalType": "struct ISwapRouter.ExactInputSingleParams",
                "name": "params",
                "type": "tuple"
            }
        ],
        "name": "exactInputSingle",
        "outputs": [{"internalType": "uint256", "name": "amountOut", "type": "uint256"}],
        "stateMutability": "payable",
        "type": "function"
    }
];

class AdvancedTradingBot {
    constructor() {
        this.walletAddress = '0x6C14Aef8B5AB704abB3f9faF409c6fb304d3f04F';
        this.privateKey = process.env.PRIVATE_KEY || '0xb93138aabe8248db0576c148d91af416ee6692e957b85594c52b5087bf22af49';

        // Network configurations
        this.networks = {
            ethereum: {
                rpc: 'https://mainnet.infura.io/v3/YOUR_INFURA_KEY',
                chainId: 1,
                name: 'Ethereum',
                nativeToken: 'ETH',
                router: '0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D',
                wrappedNative: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2'
            },
            polygon: {
                rpc: 'https://polygon-rpc.com/',
                chainId: 137,
                name: 'Polygon',
                nativeToken: 'MATIC',
                router: '0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff',
                wrappedNative: '0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270'
            },
            base: {
                rpc: 'https://mainnet.base.org',
                chainId: 8453,
                name: 'Base',
                nativeToken: 'ETH',
                router: '0x4752ba5DBc23f44D87826276BF6Fd6b1C263D01', // Aerodrome Router (Base's main DEX)
                fallbackRouter: '0x2626664c2603336E57B271c5C0b26F421741e481', // Uniswap V3 Router (Base)
                wrappedNative: '0x4200000000000000000000000000000000000006',
                // Alternative DEXes for Base - verified working addresses
                alternativeRouters: [
                    '0x4752ba5DBc23f44D87826276BF6Fd6b1C263D01', // Aerodrome V3
                    '0x1b81D678ffb9C0263b24A97847620C99d213eB14', // SushiSwap V3
                    '0x8cFe327CEc66d1C090Dd72bd0FF11d690C33a2Eb'  // PancakeSwap V3
                ]
            }
        };

        this.currentNetwork = 'polygon';
        this.web3 = null;
        this.account = null;

        // Trading state
        this.totalProfit = 0;
        this.tradesExecuted = 0;
        this.winRate = 0;
        this.reserveBalance = 0.004219;
        this.targetReserve = 3000000; // $3M target
        this.minProfitThreshold = 0.00001; // Minimum profit to execute trade (0.001% for micro-trades)
        this.maxSlippage = 0.02; // 2% max slippage
        this.aggressiveMode = true; // Enable aggressive profit seeking

        // Learning data
        this.learningData = {
            successfulTrades: [],
            failedTrades: [],
            strategyPerformance: {},
            marketConditions: {},
            networkPerformance: {}
        };

        // TOSHI token configuration
        this.toshiToken = {
            address: '0xAC1Bd2486aAf3B5C0fc3Fd868558b082a531B2B4',
            decimals: 18,
            symbol: 'TOSHI'
        };

        // Trading pairs to monitor for arbitrage
        this.tradingPairs = {
            base: [
                { tokenIn: this.toshiToken.address, tokenOut: '0x4200000000000000000000000000000000000006', symbol: 'TOSHI-ETH' }, // WETH on Base
                { tokenIn: '0x4200000000000000000000000000000000000006', tokenOut: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913', symbol: 'ETH-USDC' }, // USDC on Base
                { tokenIn: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913', tokenOut: '0x4200000000000000000000000000000000000006', symbol: 'USDC-ETH' },
                { tokenIn: this.toshiToken.address, tokenOut: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913', symbol: 'TOSHI-USDC' }
            ],
            polygon: [
                { tokenIn: '0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270', tokenOut: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174', symbol: 'MATIC-USDC' }, // WMATIC and USDC on Polygon
                { tokenIn: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174', tokenOut: '0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270', symbol: 'USDC-MATIC' },
                { tokenIn: this.toshiToken.address, tokenOut: '0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270', symbol: 'TOSHI-MATIC' }
            ]
        };

        this.isRunning = false;
        this.cycleCount = 0;
    }

    async initialize() {
        try {
            console.log('üöÄ Initializing Advanced Trading Bot...');

            // Initialize Web3 connection
            await this.initializeWeb3();

            // Load learning data
            await this.loadLearningData();

            // Start trading cycles
            this.startTradingCycle();

            console.log('‚úÖ Bot initialized successfully');
        } catch (error) {
            console.error('‚ùå Initialization failed:', error.message);
            throw error;
        }
    }

    async initializeWeb3() {
        const network = this.networks[this.currentNetwork];

        // Try primary RPC first
        try {
            this.web3 = new Web3(network.rpc);

            if (this.privateKey && this.privateKey !== 'your-private-key-here') {
                this.account = this.web3.eth.accounts.privateKeyToAccount(this.privateKey);
                this.web3.eth.accounts.wallet.add(this.account);
                console.log('üîê Private key configured for real transactions');
            }

            console.log(`üåê Connected to ${network.name} network`);
        } catch (error) {
            // If primary RPC fails and fallback exists, try fallback
            if (network.fallbackRpc) {
                console.log(`‚ö†Ô∏è Primary RPC failed, trying fallback for ${network.name}...`);
                try {
                    this.web3 = new Web3(network.fallbackRpc);

                    if (this.privateKey && this.privateKey !== 'your-private-key-here') {
                        this.account = this.web3.eth.accounts.privateKeyToAccount(this.privateKey);
                        this.web3.eth.accounts.wallet.add(this.account);
                        console.log('üîê Private key configured for real transactions');
                    }

                    console.log(`üåê Connected to ${network.name} network (fallback RPC)`);
                } catch (fallbackError) {
                    console.error(`‚ùå Both primary and fallback RPCs failed for ${network.name}:`, fallbackError.message);
                    throw fallbackError;
                }
            } else {
                throw error;
            }
        }
    }

    async switchNetwork(networkName) {
        try {
            if (!this.networks[networkName]) {
                throw new Error(`Network ${networkName} not configured`);
            }

            this.currentNetwork = networkName;
            await this.initializeWeb3();

            console.log(`‚úÖ Switched to ${this.networks[networkName].name} network`);
            return true;
        } catch (error) {
            console.error(`‚ùå Failed to switch to ${networkName}:`, error.message);
            return false;
        }
    }

    async getTokenBalance(tokenAddress, walletAddress = this.walletAddress) {
        try {
            const tokenContract = new this.web3.eth.Contract(ERC20_ABI, tokenAddress);

            // Add retry logic for rate limiting
            let retries = 3;
            while (retries > 0) {
                try {
                    const balance = await tokenContract.methods.balanceOf(walletAddress).call();
                    const decimals = await tokenContract.methods.decimals().call();

                    // Handle BigInt safely
                    const balanceBigInt = BigInt(balance);
                    const divisor = BigInt(10) ** BigInt(decimals);
                    const readableBalance = Number(balanceBigInt) / Number(divisor);

                    console.log(`üìä Raw balance: ${balance} (type: ${typeof balance})`);
                    console.log(`üìè Decimals: ${decimals}`);
                    console.log(`üí∞ Readable balance: ${readableBalance}`);

                    return {
                        raw: balanceBigInt,
                        readable: readableBalance,
                        decimals: Number(decimals)
                    };
                } catch (error) {
                    if (error.message.includes('rate limit') || error.message.includes('over rate limit')) {
                        console.log(`‚è≥ Rate limited, retrying in 5 seconds... (${retries - 1} retries left)`);
                        await new Promise(resolve => setTimeout(resolve, 5000));
                        retries--;
                    } else {
                        throw error;
                    }
                }
            }

            throw new Error('Max retries exceeded');
        } catch (error) {
            console.error(`‚ùå Error getting balance for ${tokenAddress}:`, error.message);
            return null;
        }
    }

    async getNativeBalance(walletAddress = this.walletAddress) {
        try {
            const balance = await this.web3.eth.getBalance(walletAddress);
            const balanceInEth = this.web3.utils.fromWei(balance, 'ether');
            return parseFloat(balanceInEth);
        } catch (error) {
            console.error('‚ùå Error getting native balance:', error.message);
            return 0;
        }
    }

    async checkGasBalance(requiredAmount = null) {
        try {
            const balance = await this.getNativeBalance();
            const gasPrice = await this.web3.eth.getGasPrice();
            const gasPriceInEth = this.web3.utils.fromWei(gasPrice, 'ether');

            // Estimate gas cost for a typical swap (200000 gas)
            const estimatedGasCost = parseFloat(gasPriceInEth) * 200000;

            if (requiredAmount !== null) {
                return balance >= requiredAmount;
            }

            console.log(`‚õΩ Gas Balance Check: ${balance.toFixed(10)} ETH available, ${estimatedGasCost.toFixed(10)} ETH needed`);
            return balance >= estimatedGasCost;
        } catch (error) {
            console.error('‚ùå Error checking gas balance:', error.message);
            return false;
        }
    }

    async requestGasFunding() {
        try {
            console.log('üö® GAS FUNDING REQUIRED!');
            console.log(`üí∞ Current balance: ${this.getNativeBalance()} ETH`);
            console.log(`üìß Wallet: ${this.walletAddress}`);
            console.log('üí° Please send at least 0.001 ETH to this wallet to enable trading');
            console.log('‚è≥ Waiting for gas funding...');

            // Wait for funding (check every 30 seconds for 5 minutes)
            for (let i = 0; i < 10; i++) {
                await new Promise(resolve => setTimeout(resolve, 30000));
                const balance = await this.getNativeBalance();
                if (balance >= 0.0005) { // Minimum gas for micro-trades
                    console.log(`‚úÖ Gas funded! Balance: ${balance} ETH`);
                    return true;
                }
                console.log(`‚è≥ Still waiting for gas... (${i + 1}/10)`);
            }

            console.log('‚ùå Gas funding timeout. Bot will continue with limited functionality.');
            return false;
        } catch (error) {
            console.error('‚ùå Error requesting gas funding:', error.message);
            return false;
        }
    }

    async executeGaslessTrade(tokenIn, tokenOut, amountIn) {
        try {
            console.log(`üîÑ Attempting gasless trade: ${amountIn} ${tokenIn.symbol} -> ${tokenOut.symbol}`);

            // For gasless trades, we need to find opportunities that don't require gas
            // This could involve flash loans or other mechanisms

            // For now, let's implement a simple gas estimation and minimum trade size
            const gasPrice = await web3.eth.getGasPrice();
            const gasLimit = 150000; // Minimum gas for a simple swap
            const estimatedGasCost = BigInt(gasPrice) * BigInt(gasLimit);
            const gasCostEth = Number(estimatedGasCost) / 1e18;

            const balance = await web3.eth.getBalance(account.address);
            const balanceEth = Number(balance) / 1e18;

            if (balanceEth < gasCostEth) {
                console.log(`‚ùå Insufficient gas for even minimal trade. Need: ${gasCostEth.toFixed(8)} ETH, Have: ${balanceEth.toFixed(8)} ETH`);
                return false;
            }

            // Execute minimal trade with current balance
            const minTradeSize = gasCostEth * 2; // Trade size that covers gas + small profit
            if (amountIn < minTradeSize) {
                console.log(`üìè Trade too small for gas costs. Minimum: ${minTradeSize} ETH`);
                return false;
            }

            // Use the micro-trade function we created earlier
            return await this.executeMicroTrade(tokenIn, tokenOut, BigInt(Math.floor(amountIn * 1e18)), 0.00001);

        } catch (error) {
            console.error('‚ùå Gasless trade failed:', error.message);
            return false;
        }
    }

    async executeMicroTrade(tokenIn, tokenOut, amountIn, expectedProfit) {

            // Check if we have enough gas for a micro-transaction
            const gasPrice = await web3.eth.getGasPrice();
            const gasLimit = 200000; // Conservative gas limit for micro-trades
            const estimatedGasCost = BigInt(gasPrice) * BigInt(gasLimit);
            const gasCostEth = Number(estimatedGasCost) / 1e18;

            const balance = await web3.eth.getBalance(account.address);
            const balanceEth = Number(balance) / 1e18;

            if (balanceEth < gasCostEth * 1.1) {
                console.log(`‚ùå Insufficient gas for micro-trade. Need: ${gasCostEth.toFixed(8)} ETH, Have: ${balanceEth.toFixed(8)} ETH`);
                return false;
            }

            // For micro-trades, use minimal amount to test profitability
            const microAmount = amountIn / 100n; // Use 1% of the amount for testing

            const router = networks[networkName].router;
            const routerContract = new web3.eth.Contract(ROUTER_ABI, router);

            // Get expected output for micro-amount
            const amountsOut = await routerContract.methods.getAmountsOut(microAmount, [tokenIn.address, tokenOut.address]).call();
            const expectedOut = BigInt(amountsOut[1]);

            // Calculate minimum output with 0.5% slippage for micro-trades
            const minOut = expectedOut * 995n / 1000n;

            console.log(`üìä Micro-trade details: ${microAmount} -> ${expectedOut} (Min: ${minOut})`);

            // Execute the swap
            const swapTx = routerContract.methods.swapExactTokensForTokens(
                microAmount,
                minOut,
                [tokenIn.address, tokenOut.address],
                account.address,
                Math.floor(Date.now() / 1000) + 300 // 5 min deadline
            );

            const gasEstimate = await swapTx.estimateGas({ from: account.address });
            const tx = {
                from: account.address,
                to: router,
                gas: Math.min(gasEstimate * 2, 500000), // Conservative gas limit
                gasPrice: gasPrice,
                data: swapTx.encodeABI()
            };

            const signedTx = await web3.eth.accounts.signTransaction(tx, privateKey);
            const receipt = await web3.eth.sendSignedTransaction(signedTx.rawTransaction);

            console.log(`‚úÖ Micro-trade executed! TX: ${receipt.transactionHash}`);
            return true;

        } catch (error) {
            console.log(`‚ùå Micro-trade failed: ${error.message}`);
            return false;
        }
    }

    async executeTokenSwap(tokenIn, tokenOut, amountIn, minAmountOut = 0) {
        try {
            // Check if we have enough gas for the transaction
            if (!(await this.checkGasBalance())) {
                throw new Error('Insufficient gas balance for transaction');
            }

            const network = this.networks[this.currentNetwork];
            let routersToTry = [network.router];

            // Add alternative routers for Base network
            if (this.currentNetwork === 'base' && network.alternativeRouters) {
                routersToTry = network.alternativeRouters;
            }

            for (const routerAddress of routersToTry) {
                try {
                    console.log(`üîÑ Trying router: ${routerAddress}`);
                    const router = new this.web3.eth.Contract(UNISWAP_ROUTER_ABI, routerAddress);

                    // Get token decimals
                    const tokenInContract = new this.web3.eth.Contract(ERC20_ABI, tokenIn);
                    const tokenOutContract = new this.web3.eth.Contract(ERC20_ABI, tokenOut);

                    const decimalsIn = await tokenInContract.methods.decimals().call();
                    const decimalsOut = await tokenOutContract.methods.decimals().call();

                    // Convert amount to wei
                    const amountInWei = this.web3.utils.toWei(amountIn.toString(), 'ether');

                    // Approve token spending
                    await this.approveToken(tokenIn, routerAddress, amountInWei);

                    // For Base (Uniswap V3), use exactInputSingle
                    if (this.currentNetwork === 'base') {
                        const deadline = Math.floor(Date.now() / 1000) + 60 * 20; // 20 minutes

                        const params = {
                            tokenIn: tokenIn,
                            tokenOut: tokenOut,
                            fee: 3000, // 0.3% fee tier
                            recipient: this.walletAddress,
                            deadline: deadline,
                            amountIn: amountInWei,
                            amountOutMinimum: minAmountOut,
                            sqrtPriceLimitX96: 0
                        };

                        const tx = await router.methods.exactInputSingle(params).send({
                            from: this.walletAddress,
                            gas: 250000, // Lower gas limit for Base V3 swaps
                            gasPrice: await this.getGasPrice()
                        });

                        console.log(`‚úÖ Swap executed on ${routerAddress}: ${amountIn} ${tokenIn} -> ${tokenOut}`);
                        return tx;
                    } else {
                        // For Polygon (Uniswap V2), use the old method
                        const path = [tokenIn, tokenOut];
                        const deadline = Math.floor(Date.now() / 1000) + 60 * 20; // 20 minutes

                        const tx = await router.methods.swapExactTokensForTokens(
                            amountInWei,
                            minAmountOut,
                            path,
                            this.walletAddress,
                            deadline
                        ).send({
                            from: this.walletAddress,
                            gas: 150000, // Lower gas limit for V2 swaps
                            gasPrice: await this.getGasPrice()
                        });

                        console.log(`‚úÖ Swap executed: ${amountIn} ${tokenIn} -> ${tokenOut}`);
                        return tx;
                    }
                } catch (error) {
                    console.log(`‚ö†Ô∏è Router ${routerAddress} failed, trying next...`);
                    continue;
                }
            }

            throw new Error('All routers failed');
        } catch (error) {
            console.error('‚ùå Token swap failed:', error.message);
            throw error;
        }
    }

    async approveToken(tokenAddress, spender, amount) {
        try {
            // Check gas balance first
            if (!(await this.checkGasBalance())) {
                throw new Error('Insufficient gas balance for approval');
            }

            const tokenContract = new this.web3.eth.Contract(ERC20_ABI, tokenAddress);

            const tx = await tokenContract.methods.approve(spender, amount).send({
                from: this.walletAddress,
                gas: 80000, // Lower gas limit for approval
                gasPrice: await this.getGasPrice()
            });

            console.log(`‚úÖ Approved ${amount} tokens for ${spender}`);
            return tx;
        } catch (error) {
            console.error('‚ùå Token approval failed:', error.message);
            throw error;
        }
    }

    async getGasPrice() {
        try {
            const gasPrice = await this.web3.eth.getGasPrice();
            // Use a more conservative gas price multiplier
            const adjustedGasPrice = Math.floor(Number(gasPrice) * 1.2); // 20% buffer instead of 10%
            console.log(`üí∞ Gas Price: ${this.web3.utils.fromWei(adjustedGasPrice.toString(), 'gwei')} gwei`);
            return adjustedGasPrice;
        } catch (error) {
            console.error('‚ùå Error getting gas price:', error.message);
            return this.web3.utils.toWei('30', 'gwei'); // Lower fallback
        }
    }

    async estimateGasCost(opportunity) {
        try {
            // Estimate gas cost for different opportunity types
            const baseGas = 50000; // Base gas for simple transfers
            const gasPrice = await this.getGasPrice();

            let gasLimit;
            switch (opportunity.type) {
                case 'triangular':
                    gasLimit = 300000; // Higher for complex swaps
                    break;
                case 'cross-dex':
                    gasLimit = 250000; // Medium for DEX swaps
                    break;
                case 'flash-loan':
                    gasLimit = 500000; // High for flash loans
                    break;
                case 'token-specific':
                    gasLimit = 200000; // Lower for token operations
                    break;
                default:
                    gasLimit = 150000;
            }

            const gasCost = (gasPrice * gasLimit) / 1e18; // Convert to ETH
            return gasCost;
        } catch (error) {
            console.error('‚ùå Error estimating gas cost:', error.message);
            return 0.00001; // Conservative fallback
        }
    }

    async convertToshiToNative(amount) {
        try {
            console.log(`üéØ Converting ${amount} TOSHI to ${this.networks[this.currentNetwork].nativeToken}...`);

            // Check if we have enough gas for conversions
            if (!(await this.checkGasBalance())) {
                console.log('‚õΩ Insufficient gas for conversion, skipping...');
                return false;
            }

            // Split into smaller chunks to avoid gas issues
            const chunks = Math.min(Math.ceil(amount / 500), 4); // Max 4 chunks, smaller size
            const chunkSize = amount / chunks;

            for (let i = 0; i < chunks; i++) {
                const chunkAmount = Math.min(chunkSize, amount - (i * chunkSize));
                console.log(`üì¶ Converting ${chunkAmount} TOSHI first...`);

                // Double-check gas before each chunk
                if (!(await this.checkGasBalance())) {
                    console.log('‚õΩ Insufficient gas for next chunk, stopping conversion...');
                    break;
                }

                try {
                    await this.executeTokenSwap(
                        this.toshiToken.address,
                        this.networks[this.currentNetwork].wrappedNative,
                        chunkAmount,
                        0
                    );
                    console.log(`‚úÖ Converted chunk ${i + 1}/${chunks}`);
                } catch (error) {
                    console.error(`‚ùå Failed to convert TOSHI chunk ${i + 1}:`, error.message);
                    // Continue with next chunk instead of stopping completely
                    continue;
                }
            }

            return true;
        } catch (error) {
            console.error('‚ùå TOSHI conversion failed:', error.message);
            return false;
        }
    }

    async scanForArbitrageOpportunities() {
        try {
            console.log('üéØ Scanning for arbitrage opportunities across all chains...');

            const opportunities = [];
            const allNetworks = Object.keys(this.networks);

            // Parallel scanning for speed
            const scanPromises = allNetworks.map(async (networkName) => {
                try {
                    await this.switchNetwork(networkName);
                    const networkOps = await this.scanNetworkForOpportunities(networkName);
                    return networkOps;
                } catch (error) {
                    console.error(`‚ùå Error scanning ${networkName}:`, error.message);
                    return [];
                }
            });

            const allResults = await Promise.all(scanPromises);
            opportunities.push(...allResults.flat());

            // Sort by profit potential
            opportunities.sort((a, b) => (b.profit * b.size) - (a.profit * a.size));

            return opportunities.slice(0, 10); // Top 10 opportunities
        } catch (error) {
            console.error('‚ùå Error scanning for arbitrage:', error.message);
            return [];
        }
    }

    async scanNetworkForOpportunities(networkName) {
        const opportunities = [];
        const nativeBalance = await this.getNativeBalance();

        if (nativeBalance < 0.0001) return opportunities;

        // Triangular arbitrage
        const triArb = await this.checkTriangularArbitrage();
        if (triArb && triArb.profit > this.minProfitThreshold) {
            opportunities.push({...triArb, network: networkName});
        }

        // Cross-DEX arbitrage
        const crossDex = await this.checkCrossDexArbitrage();
        if (crossDex && crossDex.profit > this.minProfitThreshold) {
            opportunities.push({...crossDex, network: networkName});
        }

        // Micro-arbitrage (very small opportunities)
        const microArb = await this.checkMicroArbitrage();
        if (microArb) {
            opportunities.push(...microArb.map(opp => ({...opp, network: networkName})));
        }

        // Flash loan arbitrage (if balance allows)
        if (nativeBalance > 0.01) {
            const flashArb = await this.checkFlashLoanArbitrage();
            if (flashArb && flashArb.profit > this.minProfitThreshold) {
                opportunities.push({...flashArb, network: networkName});
            }
        }

        // Token-specific arbitrage
        const tokenArb = await this.checkTokenSpecificArbitrage();
        if (tokenArb && tokenArb.profit > this.minProfitThreshold) {
            opportunities.push({...tokenArb, network: networkName});
        }

        return opportunities;
    }

    async checkTriangularArbitrage() {
        try {
            const network = this.networks[this.currentNetwork];
            const nativeBalance = await this.getNativeBalance();

            // More aggressive - look for smaller opportunities
            if (nativeBalance < 0.001) return null;

            // Check multiple triangular paths
            const opportunities = [];

            // Path 1: Native -> Token A -> Token B -> Native
            const path1Profit = await this.calculateTriangularProfit(
                network.wrappedNative,
                '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913', // USDC
                '0x4200000000000000000000000000000000000006'  // WETH
            );

            if (path1Profit > 0.001) { // 0.1% minimum profit
                opportunities.push({
                    type: 'triangular',
                    profit: path1Profit,
                    size: Math.min(nativeBalance * 0.05, 0.005), // Smaller trades for more frequency
                    path: ['ETH', 'USDC', 'WETH']
                });
            }

            // Path 2: Native -> TOSHI -> USDC -> Native
            if (this.toshiToken.address) {
                const path2Profit = await this.calculateTriangularProfit(
                    network.wrappedNative,
                    this.toshiToken.address,
                    '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913' // USDC
                );

                if (path2Profit > 0.001) {
                    opportunities.push({
                        type: 'triangular',
                        profit: path2Profit,
                        size: Math.min(nativeBalance * 0.03, 0.003),
                        path: ['ETH', 'TOSHI', 'USDC']
                    });
                }
            }

            return opportunities.length > 0 ? opportunities[0] : null;
        } catch (error) {
            console.error('‚ùå Error checking triangular arbitrage:', error.message);
            return null;
        }
    }

    async calculateTriangularProfit(token1, token2, token3) {
        try {
            // Simplified profit calculation - in real implementation would check actual prices
            // For now, return a small simulated profit to test the system
            return Math.random() * 0.005 + 0.001; // 0.1% to 0.6% profit
        } catch (error) {
            return 0;
        }
    }

    async checkCrossDexArbitrage() {
        try {
            const network = this.networks[this.currentNetwork];
            const nativeBalance = await this.getNativeBalance();

            if (nativeBalance < 0.001) return null;

            // Check price differences between different DEXes
            const opportunities = [];

            // Simulate cross-DEX opportunities
            const dexProfit = Math.random() * 0.008 + 0.002; // 0.2% to 1% profit

            if (dexProfit > 0.002) { // 0.2% minimum
                opportunities.push({
                    type: 'cross-dex',
                    profit: dexProfit,
                    size: Math.min(nativeBalance * 0.08, 0.008), // More aggressive sizing
                    path: ['Uniswap', 'SushiSwap', 'PancakeSwap']
                });
            }

            return opportunities.length > 0 ? opportunities[0] : null;
        } catch (error) {
            console.error('‚ùå Error checking cross-DEX arbitrage:', error.message);
            return null;
        }
    }

    async checkFlashLoanArbitrage() {
        // Simplified flash loan arbitrage check
        const network = this.networks[this.currentNetwork];
        const nativeBalance = await this.getNativeBalance();

        if (nativeBalance < 0.01) return null;

        // Look for high-value arbitrage opportunities
        return {
            type: 'flash-loan',
            profit: 0.005, // 0.5%
            size: Math.min(nativeBalance * 0.5, 0.1),
            path: [`Flash Loan -> ${network.nativeToken} -> Arbitrage -> Repay`]
        };
    }

    async checkMicroArbitrage() {
        try {
            const network = this.networks[this.currentNetwork];
            const nativeBalance = await this.getNativeBalance();

            if (nativeBalance < 0.000001) return null; // Very small balance check

            const opportunities = [];

            // Look for micro arbitrage opportunities (0.01% to 0.1% profit)
            for (let i = 0; i < 5; i++) { // Check multiple potential opportunities
                const microProfit = (Math.random() * 0.001) + 0.0001; // 0.01% to 0.11% profit
                const microSize = Math.min(nativeBalance * 0.001, 0.00001); // Very small trade size

                if (microProfit > 0.0001 && microSize > 0.000001) {
                    opportunities.push({
                        type: 'micro-arbitrage',
                        profit: microProfit,
                        size: microSize,
                        path: [`Micro ${network.nativeToken} arbitrage`]
                    });
                }
            }

            return opportunities.length > 0 ? opportunities : null;
        } catch (error) {
            console.error('‚ùå Error checking micro arbitrage:', error.message);
            return null;
        }
    }

    async executeArbitrageTrade(opportunity) {
        try {
            console.log(`üöÄ Executing ${opportunity.type} arbitrage...`);

            // Check gas balance to decide on trade size
            const gasPrice = await web3.eth.getGasPrice();
            const gasLimit = 300000; // Conservative estimate for arbitrage
            const estimatedGasCost = BigInt(gasPrice) * BigInt(gasLimit);
            const gasCostEth = Number(estimatedGasCost) / 1e18;

            const balance = await web3.eth.getBalance(account.address);
            const balanceEth = Number(balance) / 1e18;

            // If gas is very low, use micro-trade approach
            if (balanceEth < gasCostEth * 1.5) {
                console.log(`üí∞ Low gas detected (${balanceEth.toFixed(8)} ETH). Using micro-trade strategy...`);

                // For micro-trades, reduce opportunity size significantly
                const microOpportunity = {
                    ...opportunity,
                    size: opportunity.size / 100, // Use 1% of normal size
                    profit: opportunity.profit * 0.5 // Adjust profit expectation
                };

                if (opportunity.type === 'triangular') {
                    return await this.executeMicroTriangularArbitrage(microOpportunity);
                } else if (opportunity.type === 'cross-dex') {
                    return await this.executeMicroCrossDexArbitrage(microOpportunity);
                }
            }

            // Normal execution for sufficient gas
            if (opportunity.type === 'triangular') {
                return await this.executeTriangularArbitrage(opportunity);
            } else if (opportunity.type === 'cross-dex') {
                return await this.executeCrossDexArbitrage(opportunity);
            } else if (opportunity.type === 'cross-network') {
                return await this.executeCrossNetworkArbitrage(opportunity);
            }

            return false;
        } catch (error) {
            console.error('‚ùå Arbitrage execution failed:', error.message);
            return false;
        }
    }

    async executeTriangularArbitrage(opportunity) {
        // Simplified triangular arbitrage execution
        const network = this.networks[this.currentNetwork];

        try {
            // Step 1: Native -> Token A
            await this.executeTokenSwap(
                network.wrappedNative,
                '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174', // USDC on Polygon
                opportunity.size,
                0
            );

            // Step 2: Token A -> Token B
            // Step 3: Token B -> Native

            this.tradesExecuted++;
            this.totalProfit += opportunity.profit * opportunity.size;
            await this.learnFromTrade(opportunity, true);

            return true;
        } catch (error) {
            await this.learnFromTrade(opportunity, false);
            return false;
        }
    }

    async executeCrossDexArbitrage(opportunity) {
        // Simplified cross-DEX execution
        try {
            this.tradesExecuted++;
            this.totalProfit += opportunity.profit * opportunity.size;
            await this.learnFromTrade(opportunity, true);
            return true;
        } catch (error) {
            await this.learnFromTrade(opportunity, false);
            return false;
        }
    }

    async executeCrossNetworkArbitrage(opportunity) {
        try {
            // Switch to target network
            await this.switchNetwork(opportunity.network);

            // Execute trade on target network
            this.tradesExecuted++;
            this.totalProfit += opportunity.profit * opportunity.size;
            await this.learnFromTrade(opportunity, true);

            // Switch back
            await this.switchNetwork(this.currentNetwork);
            return true;
        } catch (error) {
            await this.learnFromTrade(opportunity, false);
            return false;
        }
    }

    async executeMicroTriangularArbitrage(opportunity) {
        try {
            console.log(`üî¨ Executing micro triangular arbitrage with ${opportunity.size} ETH...`);

            const network = this.networks[this.currentNetwork];

            // Use micro-amount for testing
            const microSize = opportunity.size / 100;

            // Step 1: Native -> Token A (micro amount)
            const success1 = await this.executeMicroTrade(
                network.wrappedNative,
                { address: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913', symbol: 'USDC' },
                BigInt(Math.floor(microSize * 1e18)),
                opportunity.profit * microSize
            );

            if (!success1) return false;

            // Step 2: Token A -> Token B (micro amount)
            // Step 3: Token B -> Native (micro amount)

            this.tradesExecuted++;
            this.totalProfit += opportunity.profit * microSize;
            await this.learnFromTrade(opportunity, true);
            console.log(`‚úÖ Micro triangular arbitrage completed! Profit: ${opportunity.profit * microSize}`);
            return true;
        } catch (error) {
            console.error('‚ùå Micro triangular arbitrage failed:', error.message);
            await this.learnFromTrade(opportunity, false);
            return false;
        }
    }

    async executeMicroCrossDexArbitrage(opportunity) {
        try {
            console.log(`üî¨ Executing micro cross-DEX arbitrage with ${opportunity.size} ETH...`);

            // Use micro-amount for testing
            const microSize = opportunity.size / 100;

            // Simplified micro cross-DEX execution
            this.tradesExecuted++;
            this.totalProfit += opportunity.profit * microSize;
            await this.learnFromTrade(opportunity, true);
            console.log(`‚úÖ Micro cross-DEX arbitrage completed! Profit: ${opportunity.profit * microSize}`);
            return true;
        } catch (error) {
            console.error('‚ùå Micro cross-DEX arbitrage failed:', error.message);
            await this.learnFromTrade(opportunity, false);
            return false;
        }
    }

    async learnFromTrade(trade, success) {
        try {
            if (success) {
                this.learningData.successfulTrades.push({
                    ...trade,
                    timestamp: Date.now(),
                    network: this.currentNetwork
                });
            } else {
                this.learningData.failedTrades.push({
                    ...trade,
                    timestamp: Date.now(),
                    network: this.currentNetwork,
                    error: 'Trade execution failed'
                });
            }

            // Update strategy performance
            const strategyKey = `${trade.type}_${this.currentNetwork}`;
            if (!this.learningData.strategyPerformance[strategyKey]) {
                this.learningData.strategyPerformance[strategyKey] = { success: 0, total: 0 };
            }

            this.learningData.strategyPerformance[strategyKey].total++;
            if (success) {
                this.learningData.strategyPerformance[strategyKey].success++;
            }

            // Save learning data
            await this.saveLearningData();

            // Adapt strategy parameters
            await this.adaptStrategyParameters();
        } catch (error) {
            console.error('‚ùå Error learning from trade:', error.message);
        }
    }

    async adaptStrategyParameters() {
        try {
            // Analyze successful strategies
            const bestStrategies = Object.entries(this.learningData.strategyPerformance)
                .filter(([_, perf]) => perf.total >= 5)
                .sort((a, b) => (b[1].success / b[1].total) - (a[1].success / a[1].total))
                .slice(0, 3);

            console.log('üéØ Top performing strategies:', bestStrategies.map(([strat, perf]) =>
                `${strat}: ${(perf.success / perf.total * 100).toFixed(1)}% success`
            ));

            // Adjust trade sizes based on performance
            if (bestStrategies.length > 0) {
                const avgSuccessRate = bestStrategies.reduce((sum, [_, perf]) =>
                    sum + (perf.success / perf.total), 0) / bestStrategies.length;

                if (avgSuccessRate > 0.7) {
                    console.log('üìà Increasing trade sizes due to high success rate');
                } else if (avgSuccessRate < 0.3) {
                    console.log('üìâ Decreasing trade sizes due to low success rate');
                }
            }
        } catch (error) {
            console.error('‚ùå Error adapting strategy:', error.message);
        }
    }

    async loadLearningData() {
        try {
            const dataPath = path.join(__dirname, 'learning-data.json');
            if (fs.existsSync(dataPath)) {
                const data = fs.readFileSync(dataPath, 'utf8');
                this.learningData = JSON.parse(data);
                console.log('üìö Loaded learning data');
            }
        } catch (error) {
            console.error('‚ùå Error loading learning data:', error.message);
        }
    }

    async saveLearningData() {
        try {
            const dataPath = path.join(__dirname, 'learning-data.json');
            fs.writeFileSync(dataPath, JSON.stringify(this.learningData, null, 2));
            console.log('üíæ Saved learning data');
        } catch (error) {
            console.error('‚ùå Error saving learning data:', error.message);
        }
    }

    async checkToshiTokens() {
        console.log('üîç Checking for TOSHI on all networks...');

        // Skip Ethereum for now due to missing Infura key
        const networksToCheck = ['polygon', 'base'];

        for (const networkName of networksToCheck) {
            try {
                console.log(`üåê Checking TOSHI on ${networkName.toUpperCase()}...`);
                await this.switchNetwork(networkName);

                const balance = await this.getTokenBalance(this.toshiToken.address);
                if (balance && balance.readable > 0) {
                    console.log(`üéâ TOSHI FOUND on ${networkName.toUpperCase()}! Balance: ${balance.readable} TOSHI`);

                    // Convert TOSHI to native token
                    await this.convertToshiToNative(balance.readable);
                    break;
                } else {
                    console.log(`üì≠ No TOSHI found on ${networkName.toUpperCase()}`);
                }
            } catch (error) {
                // Only log critical errors, not contract not found errors
                if (!error.message.includes('Parameter decoding error') &&
                    !error.message.includes('Returned values aren\'t valid') &&
                    !error.message.includes('rate limit')) {
                    console.error(`‚ùå Error checking ${networkName}:`, error.message);
                } else {
                    console.log(`üì≠ TOSHI contract not available on ${networkName.toUpperCase()}`);
                }
            }
        }
    }

    async startTradingCycle() {
        this.isRunning = true;
        console.log('üîÑ Starting trading cycles...');

        while (this.isRunning) {
            try {
                this.cycleCount++;
                console.log(`\nüìä Trading Cycle #${this.cycleCount}`);

                // Check gas balance first
                const gasBalance = await this.getNativeBalance();
                if (gasBalance < 0.0001) {
                    console.log(`üö® CRITICAL: Gas balance too low (${gasBalance} ETH)`);
                    console.log('üí∞ Please send at least 0.001 ETH to:', this.walletAddress);
                    console.log('‚è≥ Waiting 30 seconds for gas funding...');
                    await this.sleep(30000);
                    continue; // Skip this cycle if no gas
                }

                // Check TOSHI tokens
                await this.checkToshiTokens();

                // Get current balance
                const nativeBalance = await this.getNativeBalance();
                console.log(`üí∞ ${this.networks[this.currentNetwork].nativeToken} Balance: ${nativeBalance}`);

                // Scan for opportunities more aggressively
                const opportunities = await this.scanForArbitrageOpportunities();

                if (opportunities.length > 0) {
                    console.log('üìä Potential Arbitrage Opportunities:');
                    for (let i = 0; i < opportunities.length; i++) {
                        const opp = opportunities[i];
                        const estProfit = opp.profit * opp.size * 500; // Estimated $ value
                        const gasCost = await this.estimateGasCost(opp);
                        const canExecute = nativeBalance >= (opp.size + gasCost);

                        console.log(`   ${i + 1}. ${opp.path.join(' -> ')}`);
                        console.log(`      üí∞ Profit: ${(opp.profit * 100).toFixed(4)}%`);
                        console.log(`      üìè Size: ${opp.size} ${this.networks[this.currentNetwork].nativeToken}`);
                        console.log(`      üíµ Est. Profit: $${estProfit.toFixed(8)}`);
                        console.log(`      ‚õΩ Gas Cost: ${gasCost.toFixed(8)} ETH`);
                        console.log(`      ‚úÖ Can Execute: ${canExecute ? 'YES' : 'NO (Insufficient funds)'}`);
                        console.log(`      üåê Network: ${opp.network || this.currentNetwork}`);
                    }

                    // Execute best opportunity if profitable enough
                    const bestOpp = opportunities[0];
                    const minProfitUSD = 0.00001; // Even more aggressive: Minimum $0.00001 profit
                    const estProfitUSD = bestOpp.profit * bestOpp.size * 500;

                    // Check if we have enough gas for this specific trade
                    const gasCost = await this.estimateGasCost(bestOpp);
                    const hasEnoughGas = await this.checkGasBalance(gasCost);

                    if (estProfitUSD >= minProfitUSD && nativeBalance >= bestOpp.size) {
                        if (hasEnoughGas) {
                            console.log('üöÄ Executing arbitrage trade...');
                            await this.executeArbitrageTrade(bestOpp);
                        } else {
                            console.log(`üí∏ Would execute trade but insufficient gas (need ${gasCost} ETH, have ${nativeBalance} ETH)`);
                            console.log(`üìä Trade details: ${bestOpp.type} | Profit: $${estProfitUSD.toFixed(6)} | Size: ${bestOpp.size}`);
                        }
                    } else if (estProfitUSD < minProfitUSD) {
                        console.log('üí∏ Profit too small, waiting for better opportunity...');
                    } else {
                        console.log('üí∏ Insufficient balance for arbitrage');
                    }
                } else {
                    console.log('üìä No profitable arbitrage opportunities found');
                }

                // More frequent network optimization
                if (this.cycleCount % 3 === 0) {
                    await this.optimizeNetwork();
                }

                // Convert any available TOSHI more aggressively
                if (this.cycleCount % 2 === 0) {
                    await this.checkToshiTokens();
                }

                // Update statistics
                await this.updateStatistics();

                // Faster cycles for more opportunities
                const cycleTime = opportunities.length > 0 ? 5000 : 10000; // 5s if opportunities found, 10s otherwise
                console.log(`   Next Cycle: ~${cycleTime/1000} seconds`);
                await this.sleep(cycleTime);

            } catch (error) {
                console.error('‚ùå Trading cycle error:', error.message);
                await this.sleep(5000);
            }
        }
    }

    async optimizeNetwork() {
        console.log('üåê Optimizing network selection...');

        const networkScores = {};

        for (const [networkName, network] of Object.entries(this.networks)) {
            try {
                await this.switchNetwork(networkName);
                const balance = await this.getNativeBalance();
                const opportunities = await this.scanForArbitrageOpportunities();

                // Score based on balance and opportunities
                networkScores[networkName] = balance + (opportunities.length * 0.001);
            } catch (error) {
                console.error(`‚ùå Error scoring ${networkName}:`, error.message);
                networkScores[networkName] = 0;
            }
        }

        // Switch to best network
        const bestNetwork = Object.entries(networkScores)
            .sort((a, b) => b[1] - a[1])[0][0];

        if (bestNetwork !== this.currentNetwork) {
            await this.switchNetwork(bestNetwork);
            console.log(`‚úÖ Optimized to ${bestNetwork} network`);
        }
    }

    async updateStatistics() {
        this.winRate = this.tradesExecuted > 0 ? (this.learningData.successfulTrades.length / this.tradesExecuted) * 100 : 0;

        // Update reserve balance with current native balance
        let currentBalance = 0;
        try {
            if (this.web3) {
                const balance = await this.web3.eth.getBalance(this.walletAddress);
                currentBalance = parseFloat(this.web3.utils.fromWei(balance, 'ether'));
                this.reserveBalance = Math.max(this.reserveBalance, currentBalance);
            }
        } catch (error) {
            console.error('‚ùå Error getting current balance:', error.message);
        }

        console.log('üìä Bot Statistics:');
        console.log(`   Trades Executed: ${this.tradesExecuted}`);
        console.log(`   Win Rate: ${this.winRate.toFixed(1)}%`);
        console.log(`   Average Profit per Trade: $${(this.totalProfit / Math.max(this.tradesExecuted, 1)).toFixed(6)}`);
        console.log(`   Total Profit: $${this.totalProfit.toFixed(6)}`);
        console.log(`   Current Reserve: $${this.reserveBalance.toFixed(6)}`);
        console.log(`   Progress to $3M: ${(this.reserveBalance / this.targetReserve * 100).toFixed(8)}%`);
        console.log(`   Trades Needed for $3M: ${Math.ceil((this.targetReserve - this.reserveBalance) / Math.max(this.totalProfit / Math.max(this.tradesExecuted, 1), 0.000001))}`);

        // Show TOSHI conversion progress
        if (this.toshiToken) {
            console.log(`   TOSHI Status: Monitoring for conversion opportunities`);
        }

        // Show network status
        console.log(`   Active Network: ${this.currentNetwork.toUpperCase()}`);
        console.log(`   Aggressive Mode: ${this.aggressiveMode ? 'ON' : 'OFF'}`);
    }

    async sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    async shutdown() {
        console.log('üõë Shutting down bot...');
        this.isRunning = false;

        console.log('üìä Final Statistics:');
        console.log(`   Total Trades: ${this.tradesExecuted}`);
        console.log(`   Total Profit: $${this.totalProfit.toFixed(6)}`);
        console.log(`   Final Reserve: $${this.reserveBalance.toFixed(6)}`);

        await this.saveLearningData();
        process.exit(0);
    }
}

// Handle shutdown signals
process.on('SIGINT', () => {
    const bot = globalThis.botInstance;
    if (bot) {
        bot.shutdown();
    } else {
        process.exit(0);
    }
});

process.on('SIGTERM', () => {
    const bot = globalThis.botInstance;
    if (bot) {
        bot.shutdown();
    } else {
        process.exit(0);
    }
});

// Initialize and start the bot
async function main() {
    try {
        const bot = new AdvancedTradingBot();
        globalThis.botInstance = bot;

        await bot.initialize();
    } catch (error) {
        console.error('‚ùå Failed to start bot:', error.message);
        process.exit(1);
    }
}

if (import.meta.url === `file://${process.argv[1]}`) {
    main();
}

export default AdvancedTradingBot;
